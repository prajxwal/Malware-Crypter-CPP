#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <stdexcept>
#include <cryptopp/aes.h>
#include <cryptopp/filters.h>
#include <cryptopp/files.h>
#include <cryptopp/osrng.h>
#include <cryptopp/hex.h>

using namespace std;
using namespace CryptoPP;

vector<byte> readFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file.is_open()) {
        throw runtime_error("Failed to open file");
    }
    return vector<byte>(istreambuf_iterator<char>(file), {});
}

void writeFile(const string& filename, const vector<byte>& data) {
    ofstream file(filename, ios::binary);
    if (!file.is_open()) {
        throw runtime_error("Failed to open file");
    }
    file.write(reinterpret_cast<const char*>(data.data()), data.size());
}

vector<byte> pad(const vector<byte>& data, size_t blockSize) {
    size_t paddingSize = blockSize - (data.size() % blockSize);
    vector<byte> paddedData = data;
    paddedData.insert(paddedData.end(), paddingSize, static_cast<byte>(paddingSize));
    return paddedData;
}

int main(int argc, char* argv[]) {
    if (argc < 2) {
        cerr << "Usage: " << argv[0] << " <inputfile.exe>" << endl;
        return 1;
    }

    try {
        string inputFilename = argv[1];
        vector<byte> plaintextBytes = readFile(inputFilename);

        string encryptedFilename = "encrypted_bytes.bin";
        string keyFilename = "key.txt";

        // Define block size for AES-128
        const size_t blockSize = AES::BLOCKSIZE;

        // Pad the bytes
        vector<byte> paddedPlaintextBytes = pad(plaintextBytes, blockSize);

        // Generate a random key
        AutoSeededRandomPool rng;
        SecByteBlock key(AES::DEFAULT_KEYLENGTH);
        rng.GenerateBlock(key, key.size());

        // Encrypt the bytes in blocks
        vector<byte> encBytes(paddedPlaintextBytes.size());
        ECB_Mode<AES>::Encryption encryption;
        encryption.SetKey(key, key.size());

        ArraySource(paddedPlaintextBytes.data(), paddedPlaintextBytes.size(), true,
            new StreamTransformationFilter(encryption,
                new ArraySink(encBytes.data(), encBytes.size())
            )
        );

        // Write encrypted data and key to files
        writeFile(encryptedFilename, encBytes);
        writeFile(keyFilename, vector<byte>(key.begin(), key.end()));

        cout << "Encryption complete. Encrypted data saved to " << encryptedFilename
             << " and key saved to " << keyFilename << endl;
    } catch (const exception& ex) {
        cerr << "Error: " << ex.what() << endl;
        return 1;
    }

    return 0;
}
